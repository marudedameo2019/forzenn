---
title: "languages benchmarkをdockerで動かす"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["linux","benchmark","docker"]
published: true
---
# 序

2024年11月頃、1B回ループする以下の言語別ベンチマーク結果をよく目にしました。

https://www.linkedin.com/posts/benjamin-dicken-78797a73_more-languages-more-insights-a-few-interesting-activity-7266839380596547584-RQvT

私はこの人ではありませんが、以下でソースコードを公開されているので、

https://github.com/bddicken/languages

今回はそのソースコードをお借りし、ベンチマークをdockerで実際に動かしてみました。以下はdockerで動かす用のリポジトリと実際のスクリプトです。

https://github.com/marudedameo2019/languages_benchmark_docker

https://github.com/marudedameo2019/languages_benchmark_docker/blob/main/run_bench.sh


# 目的

序章で紹介した動画のベンチマークをdockerで誰でも動かせるようにすること

# 背景

序章の動画の映像は以下のURLで見れるHTMLでした。

https://benjdd.com/languages

(※ただし2025/9/4現在このドメインは証明書が有効期限切れになっていて見れません)

話題になった発端は Hacker News の以下の記事です。

https://news.ycombinator.com/item?id=42248315

読む限りあまりいいベンチではないのですが、見せ方が特徴的な上の動画だけたまに日本でも出てくることがありました。調べてみると、ベンチマークコードは言語の開発環境については何も書かれておらず、環境も明確ではなかったので、Linuxで動かせるようにdockerでそれらのインストールをしつつ、誰でもベンチマークを動かせるようにしてみました。ただし、**序章の動画のような図は出力できません**。

# ベンチマーク概要

## 元のベンチマーク

私が作ったものではないコードの概要です。

Hackers Newsの記事が出た当初のコードは今はlegacyコードとして通常は動かさないようになっているようです。当時のコードは各言語ごとにベンチマークプログラムをhyperfineというコマンドで呼び出し、計測・集計するという形になっていました。今はそうではなく、1Bループなら1Bループの部分だけをhyperfineを使わずプログラム側で測定・集計しており、処理系ランタイムのフットプリントによる差異を除去しています。ただし、コードが大きく違うこともあり、今はlegacyコードと比較して対応言語がかなり少なくなっています。

benchmarkの内容は以下のとおりです。

|名前|内容|
|:--|:--|
|loops|100M(current) or 1B(legacy)ループし、中で剰余や和を計算し、配列保存|
|fibonacci|再帰実装されたfibonacci。デフォルトは40まで|
|levenshtein|88個の文字列に対してlevenshtein距離の総当り計算|

機能的には、legacyコードが固定回数繰り返して測定する形だったのに対して、今のコードは所定時間を超えるまでループする形になっています。
また、legacyコードも今のコードも最初の既定回数の結果を破棄しています。

詳細はリポジトリのコードを追ってください。

https://github.com/bddicken/languages

## docker版

私が用意した方の概要です。ベンチマーク自体は上のコードを使っています(legacy側には仕組み上必要なパッチが当たってますが…)。

docker版では、元のベンチマークの今のコードをcurrent、legacyコードをlegacyとして両方実行できるようにしています。ただし、元のベンチマークでは動いているのに、こちらでは動いていない言語が結構あります。ざっくり言えば、archlinuxでAURにしかないものやAURにすらない言語をインストールしてないのが主な原因です。
元のベンチマークにはCSVデータなどをHTMLにしてサーバーから返す仕組みを別リポジトリで用意していますが、docker版ではplotlyを使って簡単なHTMLチャートを生成しています。
docker版のスクリプトをgithub workflowsで動かし、結果をexamplesに入れています。

なお、dockerイメージは8GBほどになり、スクリプト実行(all指定)はgithub actionsでも2時間くらいかかります。

詳細はリポジトリのコードを追ってください。

https://github.com/marudedameo2019/languages_benchmark_docker

# 測定結果

元のベンチマークの結果は

- currentだとCSV
- legacyだと未整形テキスト

になってます。序章の動画のHTML生成コードはないようでした。
前述したとおりcurrentだと別の方が作成したWebアプリが公開されているようです。
なので、docker版では独自のHTML生成にしてます。

以下のグラフはdocker版HTMLのグラフで、縦軸はC言語を100とした各言語の速度です(値が大きいほど速い)。

## github workflows(actions)

![](/images/5dd96c0329d595_001.png)
![](/images/5dd96c0329d595_002.png)

CPU: AMD EPYC 7763 64-Core Processor

## 我が家の環境での実行結果

![](/images/5dd96c0329d595_003.png)
![](/images/5dd96c0329d595_004.png)

CPU: AMD Ryzen 5 1400 Quad-Core Processor
(化石PCです)

# 考察

## 我が家でなぜloopsのcrystalが速かったのか

結論から言うと、生成コードのロジックが他と違ったからです。そしてこのコードは我が家のPCのプロセッサだと効果覿面だったと…。

以下はどんなコードが生成されたのかを示しています。

```shell-session
$ objdump --disassembler-color=on --visualize-jumps=extended-color -M intel -SDC crystal/run | less -R
...
   387c4:                          e8 a7 a8 fc ff               call   3070 <memset@plt>
   387c9:                          85 db                        test   ebx,ebx
   387cb:       ,----------------- 0f 84 ba 00 00 00            je     3888b <*loops<Int32>:Int32+0x14b>
   387d1:       |     ,----------- 78 51                        js     38824 <*loops<Int32>:Int32+0xe4>
   387d3:       |     |            31 c0                        xor    eax,eax
   387d5:       |     |            31 c9                        xor    ecx,ecx
   387d7:       |     |            66 0f 1f 84 00 00 00         nop    WORD PTR [rax+rax*1+0x0]
   387de:       |     |            00 00 
   387e0:       |     |     ,----> 8b 54 8c 08                  mov    edx,DWORD PTR [rsp+rcx*4+0x8]
   387e4:       |     |     |      31 f6                        xor    esi,esi
   387e6:       |     |     |      31 ff                        xor    edi,edi
   387e8:       |     |     |      0f 1f 84 00 00 00 00         nop    DWORD PTR [rax+rax*1+0x0]
   387ef:       |     |     |      00 

        10_000.times do |i|                       # 10k outer loop iterations
                10_000.times do |j|                     # 10k inner loop iterations, per outer loop iteration
                        a[i] += j % u                             # Simple sum
   387f0:       |     |     |  ,-> 01 f2                        add    edx,esi
   387f2:       |  ,--|-----|--|-- 0f 80 8e 00 00 00            jo     38886 <*loops<Int32>:Int32+0x146>
   387f8:       |  |  |     |  |   ff c6                        inc    esi
    (self + offset).value = value
   387fa:       |  |  |     |  |   89 54 8c 08                  mov    DWORD PTR [rsp+rcx*4+0x8],edx
   387fe:       |  |  |     |  |   39 de                        cmp    esi,ebx
   38800:       |  |  |     |  |   0f 44 f0                     cmove  esi,eax
   38803:       |  |  |     |  |   ff c7                        inc    edi
    while i < self
   38805:       |  |  |     |  |   81 ff 10 27 00 00            cmp    edi,0x2710
   3880b:       |  |  |     |  '-- 75 e3                        jne    387f0 <*loops<Int32>:Int32+0xb0>
                end
                a[i] += r                                   # Add a random value to each element in array
   3880d:       |  |  |     |      44 01 f2                     add    edx,r14d
   38810:       |  +--|-----|----- 70 74                        jo     38886 <*loops<Int32>:Int32+0x146>
   38812:       |  |  |     |      89 54 8c 08                  mov    DWORD PTR [rsp+rcx*4+0x8],edx
   38816:       |  |  |     |      48 ff c1                     inc    rcx
   38819:       |  |  |     |      48 81 f9 10 27 00 00         cmp    rcx,0x2710
   38820:       |  |  |     '----- 75 be                        jne    387e0 <*loops<Int32>:Int32+0xa0>
   38822:       |  |  |  ,-------- eb 50                        jmp    38874 <*loops<Int32>:Int32+0x134>
   38824:       |  |  '--|-------> 31 f6                        xor    esi,esi
```

`a[i] += j % u`を実施している辺りのコードが 387f0 〜 3880bの辺りなのですが、よく見ると除算がありません。その代わり`esi`を余計にいじっています。そしてこの`esi`こそが実は`j % u`なのです。crystalという言語を知っている方は少ないと思うので、同じロジックを書いたCのコードを以下に記載します。

```c
    for (int j = 0, k = 0; j < 10000;
         j++, k++) {  // 10k inner loop iterations, per outer loop iteration
      k = (k == u ? 0 : k);
      a[i] = a[i] + k;  // Simple sum
    }
```

このCのコードでは`k`が`esi`相当になります。こうすることで、除算命令が`inc`+`cmove`になり、私の古いPCでは大いに速度上昇効果があったということになります。

# まとめ

それなりに認知度があるベンチを任意の環境でざっくり実行できるようにするための叩き台ができた
