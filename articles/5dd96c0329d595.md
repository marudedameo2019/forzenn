---
title: "languages benchmarkをdockerで動かす"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["linux","benchmark","docker"]
published: true
---
# 序

2024年11月頃、1B回ループする以下の言語別ベンチマーク結果をよく目にしました。

https://www.linkedin.com/posts/benjamin-dicken-78797a73_more-languages-more-insights-a-few-interesting-activity-7266839380596547584-RQvT

私はこの人ではありませんが、以下でソースコードを公開されているので、

https://github.com/bddicken/languages

今回はそのソースコードをお借りし、ベンチマークをdockerで実際に動かしてみました。以下はdockerで動かす用のリポジトリと実際のスクリプトです。

https://github.com/marudedameo2019/languages_benchmark_docker

https://github.com/marudedameo2019/languages_benchmark_docker/blob/main/run_bench.sh


# 目的

序章で紹介した動画のベンチマークをdockerで誰でも動かせるようにすること

# 背景

序章の動画の映像は以下のURLで見れるHTMLでした。

https://benjdd.com/languages

(※ただし2025/9/4現在このドメインは証明書が有効期限切れになっていて見れません)

話題になった発端は Hacker News の以下の記事です。

https://news.ycombinator.com/item?id=42248315

読む限りあまりいいベンチではないのですが、見せ方が特徴的な上の動画だけたまに日本でも出てくることがありました。調べてみると、ベンチマークコードは言語の開発環境については何も書かれておらず、環境も明確ではなかったので、Linuxで動かせるようにdockerでそれらのインストールをしつつ、誰でもベンチマークを動かせるようにしてみました。ただし、**序章の動画のような図は出力できません**。

# ベンチマーク概要

## 元のベンチマーク

私が作ったものではないコードの概要です。

Hackers Newsの記事が出た当初のコードは今はlegacyコードとして通常は動かさないようになっているようです。当時のコードは各言語ごとにベンチマークプログラムをhyperfineというコマンドで呼び出し、計測・集計するという形になっていました。今はそうではなく、1Bループなら1Bループの部分だけをhyperfineを使わずプログラム側で測定・集計しており、処理系ランタイムのフットプリントによる差異を除去しています。ただし、コードが大きく違うこともあり、今はlegacyコードと比較して対応言語がかなり少なくなっています。

benchmarkの内容は以下のとおりです。

|名前|内容|
|:--|:--|
|loops|100M(current) or 1B(legacy)ループし、中で剰余や和を計算し、配列保存|
|fibonacci|再帰実装されたfibonacci。デフォルトは40まで|
|levenshtein|88個の文字列に対してlevenshtein距離の総当り計算|

機能的には、legacyコードが固定回数繰り返して測定する形だったのに対して、今のコードは所定時間を超えるまでループする形になっています。
また、legacyコードも今のコードも最初の既定回数の結果を破棄しています。

詳細はリポジトリのコードを追ってください。

https://github.com/bddicken/languages

## docker版

私が用意した方の概要です。ベンチマーク自体は上のコードを使っています(legacy側には仕組み上必要なパッチが当たってますが…)。

docker版では、元のベンチマークの今のコードをcurrent、legacyコードをlegacyとして両方実行できるようにしています。ただし、元のベンチマークでは動いているのに、こちらでは動いていない言語が結構あります。ざっくり言えば、archlinuxでAURにしかないものやAURにすらない言語をインストールしてないのが主な原因です。
元のベンチマークにはCSVデータなどをHTMLにしてサーバーから返す仕組みを別リポジトリで用意していますが、docker版ではplotlyを使って簡単なHTMLチャートを生成しています。
docker版のスクリプトをgithub workflowsで動かし、結果をexamplesに入れています。

なお、dockerイメージは8GBほどになり、スクリプト実行(all指定)はgithub actionsでも2時間くらいかかります。

詳細はリポジトリのコードを追ってください。

https://github.com/marudedameo2019/languages_benchmark_docker

# 測定結果

元のベンチマークの結果は

- currentだとCSV
- legacyだと未整形テキスト

になってます。序章の動画のHTML生成コードはないようでした。
前述したとおりcurrentだと別の方が作成したWebアプリが公開されているようです。
なので、docker版では独自のHTML生成にしてます。

以下のグラフはdocker版HTMLのグラフで、縦軸はC言語を100とした各言語の速度です(値が大きいほど速い)。

## github workflows(actions)

![](/images/5dd96c0329d595_001.png)
![](/images/5dd96c0329d595_002.png)

CPU: AMD EPYC 7763 64-Core Processor

## 我が家の環境での実行結果

![](/images/5dd96c0329d595_003.png)
![](/images/5dd96c0329d595_004.png)

CPU: AMD Ryzen 5 1400 Quad-Core Processor
(化石PCです)

# まとめ

それなりに認知度があるベンチを任意の環境でざっくり実行できるようにするための叩き台ができた
