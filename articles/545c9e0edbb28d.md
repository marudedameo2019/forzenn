---
title: "Windowsで子プロセスと端末の話"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["windows","cpp"]
published: false
---
# 序

前々回はCランタイムのロケールの話をし、前回の話ではWindowsの端末入出力がクライアントからどう制御されるかを粗方説明しました。今回はそれらの知見を踏まえ、子プロセスを起動する話をしようと思います。さらに、子プロセスとして起動されるプロセスが、端末かどうかで動作が変わる場合も考慮します。

今まで説明した仕組みを参考にすれば、文字化けの原因究明や解決は可能なのですが、文字化けの仕組みが分からない場合の現象切り分けや、自動テストなどの際に多少役に立つかも程度の話になります。

# 1. Windowsで子プロセスを起動するには…

今回起動させるプロセスはこんなシェルスクリプトを想定しています。

https://github.com/marudedameo2019/terminal_and_child_process/blob/main/child.sh

1～100まで1行ずつ出力したのをページャーで見るだけのものです。

## 1-1. `system()`使用

一番簡単なのはCランタイムの`system()`関数を使う方法です。

https://github.com/marudedameo2019/terminal_and_child_process/blob/main/call_system.cpp

Windowsのシェルである`cmd`や`poertshell`や`explorer`などからも起動するので、shibang(`#!/bin/sh`)は機能しません。なので、`sh`を起動して`-c`オプションで実際のコマンドラインを記述しています。二重引用符で括られた`"PATH=$PATH:/usr/bin ./child.sh"`がシェルが解釈するコマンドライン文字列になります。最初の`PATH=$PATH:/usr/bin`という部分は環境変数`PATH`を次の`./child.sh`を実行するときだけ変更する、という書き方です。`PATH`環境変数には`/usr/bin`が追加されています。

sh.exe起動時には原則それまでのWindowsのPATH環境変数を引き継いで(中には部分的に削られるものもある)いて、`mount`はされているものの、/usr/binすらPATHに入っていないからです。これが入っていないと、`child.sh`内で使用されている`seq`や`less`コマンドが見つかりません。

なので、やや込み入った文字列になっていますが、やっていることはchild.shの実行だけなのです。

実際に実行すると、コマンドライン文字列が一旦表示されたあと、普通にchild.shを実行したときと同じ動きになります。`system()`関数はパイプなどを使わず、同期実行となるので、一度起動するとユーザーが子プロセスを終了させるまで何もできません。仮にやりたいことが自動実行だった場合は、それが出来ないということです。

## 1-2. `CreateProcess()`API使用

自動実行するにはパイプが必要だということで、今度は[CreateProcess](https://learn.microsoft.com/ja-jp/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa)を使ってみます。

https://github.com/marudedameo2019/terminal_and_child_process/blob/main/call_createprocess.cpp

実行してみると分かるのですが、ページャーの`less`がページングしてくれません。これはlessが**端末実行でないと判断しているため**です。前回端末かどうかの判定方法を説明しましたが、lessは主にstdoutがキャラクタデバイスかどうかを見て端末かどうかを判断しています。今回stdoutはパイプなのでキャラクタデバイス判定されず、端末と判定されず、ページングされなかったということです。しかし自動実行したり確認したいのはページングの部分なのです。これはどう実現すればいいのでしょう？

## 1-3. 疑似端末の使用

[CreatePseudoConsole()](https://learn.microsoft.com/ja-jp/windows/console/createpseudoconsole)APIを使用します。正確には[疑似コンソール](https://learn.microsoft.com/ja-jp/windows/console/creating-a-pseudoconsole-session)と呼んでるものです。端末をホストするアプリを作成し、その上でコンソールアプリを起動させるというものです。ホスト側はコンソールアプリが出力したエスケープシーケンスなどを処理して、正しくコンソール本体などに反映させないといけません。とはいえ、コンソール本体にエンコーディングだけ合わせてそのまま流し込めば大丈夫です。

https://github.com/marudedameo2019/terminal_and_child_process/blob/main/call_createpseudoconsole.cpp

今回は待ち合わせのため、使用するエスケープシーケンス(MSの用語では[コンソール仮想ターミナル シーケンス](https://learn.microsoft.com/ja-jp/windows/console/console-virtual-terminal-sequences))を読み飛ばせるようにだけ実装を入れたら、少々長くなってしまいました。待ち合わせと言ってるのは`less`が出力している、画面下の`:`です(実際にはもう1つ、`(END)`があります)。出力する文字列の末尾が`:`だったら、次ページを要求する空白を送ったりしています(ほかにも待ち合わせ文字列があるのですが、これは別のシェルスクリプト用です)。

待ち合わせ成功時はすぐに送ると目視確認に困るので、1秒だけディレイを入れています。

大雑把な処理は以下のとおりです。

**メインスレッド**

1. コンソールモードの設定(疑似コンソール用の必須設定だけ入れる)
1. ホスト側(コチラ)とクライアント側(lessとか起動する方)をつなぐパイプを2つ用意
1. 疑似コンソールの作成
1. 通信用のスレッド作成
1. 子プロセス用の起動時スレッド属性を用意(疑似コンソール属性が必要)
1. 子プロセス起動
1. 子プロセス終了待ち
1. 各種リソースの破棄

**通信用スレッド**

1. 子プロセスの端末出力が繋がっているパイプから読み込み
1. エスケープシーケンスを読み飛ばしながら、行末の特定文字列を探す
1. 見つかったら1秒待って子プロセスの端末入力が繋がっているパイプに` `や`q`を書き込む
1. 読み込めなくなるまで読み込んだ内容を標準出力(本物の端末)に垂れ流す

※待ち合わせ処理は正直かなりアバウトなので、実用には堪えません
※デッドロックの可能性も多分あります
※端末の状態によっては表示が壊れて制御できなくなる場合があります

# 2. まとめ

子プロセスがパイプと端末で処理を変える場合は、(ちょっと大変だけど)疑似コンソールを使うと子プロセスに端末と思わせながら操作することができる