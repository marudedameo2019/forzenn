---
title: "MSYS2のススメ"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["windows","msys2","mingw","cygwin"]
published: true
---
# 序

よく考えたら[MSYS2](https://www.msys2.org/)はZennにトピックアイコンもないし、馴染みのない人が多いかもしれない、と思い、何に近くて何でないのかを多少記事にしてみようと書いてみました。

一言で言えばWindows上で〇nixライクな開発を実現するための環境だと思います。

# 1. 歴史

ポエムです。

## 1-1. Windows 95とcygwinの登場

(日本では)1993年[Windows 3.1](https://ja.wikipedia.org/wiki/Microsoft_Windows_3.x)が世に出てMS-DOSは共通のGUI環境を手に入れました。その2年後、[Windows 95](https://ja.wikipedia.org/wiki/Microsoft_Windows_95)が出て、Windowsは32bitの近代的なOSの枠組みを手に入れました。それまではワークステーションなどサーバー用途なマシンにしかなかった機能の多くをクライアント系のOSが手に入れたのです。

そんな中、サーバーと言えば〇nixライクなOS一色だった当時、それらが得意だった人たちは、Windowsにも〇nixライクな操作感というか、もっと使いやすいCLI環境を望みました。

それらの需要を背景に、同1995年[Cygnus Solutions](https://en.wikipedia.org/wiki/Cygnus_Solutions)から[cygwin](https://en.wikipedia.org/wiki/Cygwin)が生まれました。**Windows上で動作するPOSIXシステムコールAPIをエミュレートするライブラリ**を持ち、それを用いたWindowsネイティブなバイナリをビルドすることが出来る環境でした。開発環境と言えばVisual C++をはじめとした商用ソフトを購入するしかなかった当時、無料だったcygwinはそれなりに広まったわけです。

## 1-2. MinGWという選択

しかしcygwinはPOSIXシステムコールAPIをエミュレートしている分、ややもっさりしていました。それらのエミュレーションは〇nixライクな環境のプログラムを移植するには非常に便利だったものの、Windowsネイティブなプログラムをスクラッチから書く場合にはメリットがありません。[MinGW](https://en.wikipedia.org/wiki/MinGW)はそんな純粋なWindowsネイティブアプリを開発するために、1998年cygwinから生まれました。MinGWはgccのビルドで[ターゲットをMinGWにしたもの](https://gcc.gnu.org/onlinedocs/gcc/Cygwin-and-MinGW-Options.html)です。POSIXシステムコールAPIをエミュレートするライブラリへの依存を排除し、Microsoft製のCランタイムライブラリを使用するようになります。

こうしてcygwinで作られたバイナリは、

- cygwin環境で動くもの(cygwin数字.dllが必要なもの)
- cygwin環境から切り離しても使える(mingwをターゲットとした)もの

の2種類が共存するようになりました。

## 1-3. VM到来など外部要因

1999年x86仮想化を利用したVMwareなどのVM製品が生まれます。これによりWindows上でLinuxなど〇nixライクなOSが動くようになりました。VMは別ホストになるので、本来競合はしないのですが、利用目的などで当時cygwinなどと比べられることが多かったわけです。VMは起動にも時間がかかるし常駐するので重いのですが、何せ本物の〇nixライク環境であり、機能や品質の面ではcygwinとは比較になりません。(余談: 2004年には一部のマニアに知られる[Cooperative Linux](https://en.wikipedia.org/wiki/Cooperative_Linux)も登場します。Windows上に専用のドライバとアプリを動かし、その上で改変されたLinuxカーネルを動かすというものです。一部の特権をドライバで使うことで、WindowsとLinuxのカーネルが協調動作する形になり、非常に少ないリソースで動かすことが出来ました)

また直接の競合である[Windows Services for UNIX(SFU)](https://ja.wikipedia.org/wiki/Microsoft_Windows_Services_for_UNIX)も1999年Microsoftからリリースされました。こちらはWindows本体のサブシステムとしてcygwinと同じ層を提供しており、〇nixの一連のコマンドセットも附属させています。最初は有償でサーバーOS上のものでしたが、2004年には無償かつクライアントOSでも利用可能になりました。競合として最強の純正品が現れたことになります。ただ、SFUはサブシステムというWindows自身のコンポーネントを追加する仕様に抵抗があったのか、そこまで一般普及はしませんでした

さらに2005年にはVisual StudioもExpressエディションが作られ、無償化します。

この辺からcygwinには冬の時代が訪れていました。

## 1-4. 64bit時代

ここまでのcygwin/mingwは32bitでした。しかし、この辺の時代から徐々に64bitへのシフトが始まります。上述したとおり、cygwinは一般ユーザーにとって主な役目を終えつつありましたが、世に出回るOSSの多くはgccをはじめとした[GNU Tool chain](https://ja.wikipedia.org/wiki/GNU%E3%83%84%E3%83%BC%E3%83%AB%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3)に依存しているため、この頃にはWindowsにも対応しているソフトは大半がmingwを使っていました。なので、64bit化は急務と言えます。

そこで2005年に登場したのが[Mingw-w64](https://en.wikipedia.org/wiki/Mingw-w64)です。

## 1-5. MSYS2の登場

実際にMSYSが誕生したのは2001年らしく、MSYS2が出るまでよく分からず、現在msys.orgは存在していません。MSYS2は2016年頃(ここは不明)に[MSYSを置き換えると同時に、その問題を回避するために作成された](https://www.msys2.org/wiki/History/)そうです。

**基本的にMSYS2はMinGW_w64向けの環境**ということなのですが、**ベースはcygwin**になっています。ベースがcygwinなのでTUIな開発環境の基本的な構成要素を持っています。そしてMinGW_w64向けのバイナリ(つまりcygwin環境から切り離しても使えるWindowsネイティブなバイナリ)を開発することが出来る環境です。
(正直私は2005年くらいからcygwinもmingwも使っていなかったので、この間のMSYS関連はよく知りません。)

そんな経緯で、MSYS2にはcygwinの系譜であるMSYS環境と、MinGWのための3種類の環境があります。その3種類はCランタイムで分けたMinGW64環境とUCRT64環境、さらにgccではなくclangでビルドしたMinGWのためのCLANG64環境です。clangもあるということで、MSYS2にはさらにarm向けの環境、CLANGARM64も存在しています。

MSYS2が出た当初にはもうdockerもWSLもありました。MSYS2はVMでもコンテナでもハイパーバイザーでもなく、cygwin派生の開発環境を持つ主に(POSIXエミュレーションのない)Windowsネイティブアプリを作るための環境で、目的としては比較的VC++に近い環境です。

## 1-6. まとめ

歴史的に…

- MSYS2は主にMinGW_w64向けのPOSIXエミュレーションのないWindowsネイティブなx86-64アプリの開発環境です
- いくつかの派生環境が用意されており、ランタイムやコンパイラ、ターゲットを選べます

# 2. 各環境について

MSYS2には環境がいくつか存在します。

https://www.msys2.org/docs/environments/

ここでは各環境の細かい点を説明をします。

## 2-1. 前提

パッケージ管理は[arch linux](https://archlinux.org/)でお馴染みの[pacman](https://wiki.archlinux.jp/index.php/Pacman)で行われています。

全環境のパッケージが一元的にここで管理されています。各パッケージは「環境名/パッケージ名」で管理されていて、環境名はx86-64なら以下の4つになります。
- msys
- ucrt64
- mingw64
- clang64

パッケージは例えばbashなら

- msys/bash

という感じです。bashはmsys環境のものしかなく、msys2インストール時に最初からインストールされています。環境ごとにパッケージが違うものは例えばgccです。

- msys/gcc
- ucrt64/mingw-w64-ucrt-x86_64-gcc
- mingw64/mingw-w64-x86_64-gcc

各gccはそれぞれインストール先が違うだけで、どの環境からもどのパッケージを入れることもできます。
PATH環境変数の違いによりどのgccが起動するかが変わってくるだけです。

## 2-2. MSYS環境

この環境でビルドされたバイナリは`msys-2.0.dll`に依存していて、POSIXシステムコールAPIのエミュレートをしています。つまりcygwin派生のバイナリです。Microsoft製のCランタイムライブラリには直接依存していないため、パス指定やエンコーディングの設定なども〇nixライクな環境に近いものが使えます。
この環境は原則MSYS2内でのみ使用したいコマンドを作る際に使用します。

__パス指定の例__

例えば、`bash`はこの環境のパッケージなので、`/dev/null`などの特殊ファイルが使えます。

```shell-session
user@host UCRT64 /c
$ echo 'ほげ' >/dev/null

user@host UCRT64 /c
$ cygpath -w /dev/null
\\.\NUL

user@host UCRT64 /c
$ cmd
Microsoft Windows [Version 10.0.26200.7171]
(c) Microsoft Corporation. All rights reserved.

C:\>dir msys64\dev\null
 ドライブ C のボリューム ラベルは xx です
 ボリューム シリアル番号は xxxx-xxxx です

 C:\msys64\dev のディレクトリ

ファイルが見つかりません

C:\>echo ほげ >nul

C:\>dir nul

 \\. のディレクトリ

ファイルが見つかりません

C:\>exit

user@host UCRT64 /c
$ 
```

途中確認している`C:\msys64\dev`ディレクトリは、MSYS2環境の`/`がデフォルトだと`C:\msys64`になっているため、`/dev`相当のディレクトリに`null`というファイル出来ていないかを確認するためです。

`ls`(coreutils)もこの環境のパッケージなので、`/proc`などの特殊ディレクトリが使えます。

```shell-session
user@host UCRT64 /c
$ ls -F /proc
273/  325/      cpuinfo    filesystems  meminfo  net/        registry32/  stat   sysvipc/
316/  362/      cygdrive@  loadavg      misc     partitions  registry64/  swaps  uptime
324/  codesets  devices    locales      mounts@  registry/   self@        sys/   version

user@host UCRT64 /c
$ cmd
Microsoft Windows [Version 10.0.26200.7171]
(c) Microsoft Corporation. All rights reserved.

C:\>dir msys64\proc
 ドライブ C のボリューム ラベルは xx です
 ボリューム シリアル番号は xxxx-xxxx です

 C:\msys64 のディレクトリ

ファイルが見つかりません

C:\>exit

user@host UCRT64 /c
$ 
```

ここでも、`/proc`相当の`C:\msys64\proc`を調べていますが、存在していません。

__エンコーディングの設定の例__

`date`(coreutils)もこの環境のパッケージなので、環境変数指定によりロケールが変わります。

```shell-session
user@host UCRT64 /c
$ LANG=C date
Fri Dec  5 00:00:00 JST 2025

user@host UCRT64 /c
$ LANG=ja_JP.UTF-8 date
2025年 12月  5日 金曜日 00:00:00 JST

user@host UCRT64 /c
$ 
```

POSIXシェルの環境変数のプレフィックス指定付きコマンド実行機能で、環境変数`LANG`を変えながら`date`を呼び出しています。

__ファイルの配置場所__

この環境のパッケージは原則`/usr`にファイルを配置しています。


__パス変換の弊害__

この環境の自動パス変換は主にbashなどのプロセスが子プロセス起動時に行うことになりますが、例えば`cmd /c "echo hoge"`などとした場合、`/c`はパスであると判断されて、勝手に`c:\`に変換されてしまい、`cmd c:\\ "echo hoge"`と打った結果と同じになってしまいます。パス変換を無効にするには、この例だと`MSYS2_ARG_CONV_EXCL=/c cmd /c "echo hoge"`のようにすればOKです。`MSYS2_ARG_CONV_EXCL`環境変数を使用するということですが、詳しくは[ドキュメント](https://www.msys2.org/docs/filesystem-paths/)を読んでください。

## 2-3. UCRT64環境

この環境はx86-64なWindowsのネイティブコマンド(アプリ)を作る際に使用します。
Microsoft製のCランタイムライブラリである`ucrtbase.dll`に依存したアプリになり、このDLLはWindows10以降にデフォルトで入っているため、原則作成したアプリはどこに配置しても動きます(依存してるDLLにパスが通ってる限り)。現MSYS2のデフォルト環境です。

__ファイルの配置場所__

この環境のパッケージは原則`/ucrt64`にファイルを配置しています。

## 2-4. MINGW64環境

この環境はx86-64なWindowsのネイティブコマンド(アプリ)を作る際に使用します。
Microsoft製のCランタイムライブラリである`msvcrt.dll`に依存したアプリになり、このDLLは少なくともWindows XP以降にデフォルトで入っています。サポート期限はずっと前に切れており、本来であれば通常使わないライブラリになります。理由があってサポート期限の切れた古いOSにも対応したい場合に使用する環境です。古いライブラリなので、Unicodeが(使えないわけではありませんが)不完全な対応になっています。

__ファイルの配置場所__

この環境のパッケージは原則`/mingw64`にファイルを配置しています。

## 2-5. CLANG64環境

この環境はx86-64なWindowsのネイティブコマンド(アプリ)を作る際に使用します。
Microsoft製のCランタイムライブラリである`ucrtbase.dll`に依存したアプリになり、このDLLはWindows10以降にデフォルトで入っているため、原則作成したアプリはどこに配置しても動きます(依存してるDLLにパスが通ってる限り)。gccの代わりにclangを使用します。

__ファイルの配置場所__

この環境のパッケージは原則`/clang64`にファイルを配置しています。

## 2-6. CLANGARM64環境

armなWindowsを持っていないので興味なく、省略…

# 3. まとめ

MSYS2は…

- 主にMinGW_w64向けのWindowsネイティブなx86-64アプリの開発環境
- ランタイムやコンパイラが違ういくつかの環境を混合して使用できる
- cygwin由来のPOSIXエミュレーションを含むコマンドも作れる

詳細は本家ドキュメントなどを参照してください。