---
title: "std::expectedとrailway"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cpp"]
published: true
---
# 序

前回[Qiitaの過去記事を再掲](https://zenn.dev/dameyodamedame/articles/8d903b6d9d1093)した続きです。前回は`union`に焦点を当て、自力で`std::expected`の骨子を実装する方法を見ましたが、今回は`std::expected`の使い方に焦点を当ててみます。「Railway Oriented Programming」というやつです。

大層な名前がついてますが、鉄道のように一気通貫で処理を書く、というだけのもので、記事ではその簡単なサンプル実装を書いてみています。

このスタイルで書くには前回のコードだけでは出来ないので、今回はC++17で`std::variant`を使った簡易実装も用意しています。C++17である理由は、私がubuntuのLTSでデフォルトで入るgccでデフォルト設定のC++バージョンに合わせてコードを書いているからです。

# 1. お題

以下の例外で書かれたC++コードを、Railway Oriented ProgrammingなスタイルのC++23コードに書き直してください。

https://github.com/marudedameo2019/sresult/blob/main/no_railway_exception.cpp

このコードは標準入力から3行intを読んで、その合計を出力します。
その際、簡単なバリデーションもどきをやっていて、エラーを出しています。そのエラーが例外で伝えられているということです。

※このコードをビルドする方法はgithubの方のreadmeを見てください(見なくても自分でビルド出来ると思いますが)。

## 1-1. 実行例

まずはコードを書き換える前に、どんな入力のとき、どんな出力をするのかを載せておきます。実施しているのはいずれも以下の4パターンです。

- 3回正常にintを入力できて、合計値を出力しているパターン
- 整数値以外の入力を検出し、エラーを出しているパターン
- intの範囲外の入力を検出し、エラーを出しているパターン
- 入力切断を検出し、エラーを出しているパターン

※2つ目の検出はザルで、数字の後ろに何があってもエラーになりません

__🟩 WindowsでVisual Studioのpowershellからcmakeでビルドした場合__

ディレクトリやビルドディレクトリは任意です。
ここでは`c:\sresult`に`git clone`して、cmakeのビルドディレクトリを`c:\sresult\build_vs`にして、ビルドのconfigをReleaseにしている想定です。

```shell-session
PS C:\sresult> .\build_vs\Release\no_railway_exception.exe
1
2
3
合計: 6
PS C:\sresult> .\build_vs\Release\no_railway_exception.exe
1
2

エラー: 不正な引数!
PS C:\sresult> .\build_vs\Release\no_railway_exception.exe
1
2
11111111111111111111111111111111111111
エラー: 範囲外!
PS C:\sresult> .\build_vs\Release\no_railway_exception.exe
1
2
^Z
エラー: 読み込みエラー!
PS C:\sresult>
```

__🟩 WindowsでMSYS2のbashからcmake(gcc)でビルドした場合__

```shell-session
user@host UCRT64 /c/sresult
$ ./build/no_railway_exception.exe
1
2
3
合計: 6

user@host UCRT64 /c/sresult
$ ./build/no_railway_exception.exe
1
2

エラー: 不正な引数!

user@host UCRT64 /c/sresult
$ ./build/no_railway_exception.exe
1
2
1111111111111111111111111111111
エラー: 範囲外!

user@host UCRT64 /c/sresult
$ ./build/no_railway_exception.exe
1
2
^Z
エラー: 読み込みエラー!

user@host UCRT64 /c/sresult
$ 
```

__🟩 Linuxの場合__

```shell-session
user@user-pc:~/github/sresult$ ./build/no_railway_exception 
1
2
3
合計: 6
user@user-pc:~/github/sresult$ ./build/no_railway_exception 
1
2

エラー: 不正な引数!
user@user-pc:~/github/sresult$ ./build/no_railway_exception 
1
2
111111111111111111111111111
エラー: 範囲外!
user@user-pc:~/github/sresult$ ./build/no_railway_exception 
1
2
エラー: 読み込みエラー!
user@user-pc:~/github/sresult$ 
```

## 1-2. 書き換えの動機

先のコードは簡単なバリデーションもどきをやっていて、エラーを出していますが、そのエラーが例外で伝えられています。
個人的にはこのコードで問題があるとは思いませんが、仮に数百/数千倍の大きなコードで例外がもりもり発生したら恐らく収集つかないだろうな、とは思います。そういう一抹の不安がよぎるコードではあるということです。

前回見たように、`std::expected`みたいなものは例外を戻り値に入れる形だったので、この種の不安の対処に打ってつけです。それが書き換えの動機というわけです。

# 2. `std::expected`を使用する

最終的にはC++17で動かしたいのですが、まずはC++23の本物の`std::expected`を使用して、動くコードを書いてみます。C++23で動かすにはそれなりに新しいコンパイラが必要なので、注意してください。

## 2-1. C++23で動かす

以下のコードが`std::expected`を使って動かせるコードです。

https://github.com/marudedameo2019/sresult/blob/main/railway_function.cpp

C++23でない場合は勝手にC++17の代替コード(sresult.h)を使ってしまうので、CMakeLists.txtのオプション`USE_CPP23`を`on`に変えてからビルドしてください(コマンドラインから`-DUSE_CPP23=on`でもOK)。手動でビルドしてる方は、`-std=c++23`(gcc/clang)とか、`/std:c++23preview`(vs2022)にすればOKです。代替コードの詳細については後述しますので一旦置いておいてください。`#if`などマクロで条件コンパイルしてる部分が該当するので、そこを読み飛ばして頂ければOKです。

今回のコードでは関数を超える例外がなく、安全性が目に見えて上がっています。ただ、どの辺がrailwayなのかはよく分かりませんね。

どの辺がrailwayなのかというと、例えばこの辺です(もう一箇所ありますが…)。

```cpp
  auto r = expected<int, localerror>{3}  // 正常値3のexpectedを作成
               .and_then(input_numbers)
               .transform(sum)
               .transform_error(error_to_wstring);
```

一見して分かるとおり、エラーの分岐が見当たりません。例えば`and_then`とかではエラーが出るのですが、構わず処理を続けてるように見えます。例外がないので、途中で処理を抜けたりも出来ません。どういうことかというと、次の`transform`では、直前の戻り値の`expected`がエラーの場合何もしないという仕様になっているのです。つまりエラーなら何もしないというルールの元に、処理を一気通貫で行う、というのがrailwayということです。

最後に`transform_error`でまとめてエラーを文字列に変換し、例外と同様の処理感で実装を書くことが出来ています。それらの表示部分を見ると`std::expected`が単純であることが分かると思います。

余談ですが、C++では`map`(写像)を`transform`という言葉で表現しています。そこが分かれば、別の言語の似たような仕組みと同じであることが分かると思います。

なお、C++の`expected`のメソッドチェインは並行/並列的な処理には対応していません。あくまでシーケンシャルな動作のみになります。`std::expected`自体の日本語の詳細な説明については、以下を見てください(railway的な説明はないけど…)。

https://cpprefjp.github.io/reference/expected/expected.html

## 2-2. さらにラムダ式で書いてみる

今度はこのコードをラムダ式を使って書いてみます。

https://github.com/marudedameo2019/sresult/blob/main/railway_lambda.cpp

かなり一気通貫度合いが上がり、railwayな感じに見えますね。まあ関数名が消えるし、関数あたりのコードが長くなるし、インデントも深くなるしで、分かりにくさも跳ね上がっていますが…。

ただその気になればこう書ける、というのはメリットです。自分で必要だと思うところだけ関数に出すことで、`std::expected`を一箇所に集約させることも出来るかもしれません。

## 2-3. `std::expected`に対する疑問

使っていると疑問もわいてくるものです。こういうrailway的な使い方をした場合、

- メモリはいつ解放されるのか？
- 速度的な懸念はないのか？

辺りです。

メモリについては、メソッドチェインをする際の`std::expected`オブジェクトがいつ生成され、moveコンストラクタが使われるのか？が焦点になります。速度については、結局大きなところはメモリのところが大きいのでそれ次第というところでしょう。

# 3. 調査

つまり、

- `std::expected`オブジェクトがいつ生成され、moveコンストラクタが使われるのか？

を軸に調べていき、大きなコピーが発生しそうな条件を見つければ良さそうです。最後に簡単な測定でもして確認すればいいでしょう。

## 3-1. moveコンストラクタがいつ使われるのか？

表記の件を知るために、以下を調べてみました

- メソッドチェインをしたときに各`std::expected`オブジェクトの中身はmoveするのか？
- メソッドチェインの各結果を変数に格納した場合、`std::expected`オブジェクトの中身はmoveするのか？
- メソッドチェインの各結果をconst変数に格納した場合、`std::expected`オブジェクトの中身はmoveするのか？

基本的に気になるのは大きなデータということで、結果に格納するものは`vector`としました。今回はこのvectorのコンストラクタとデストラクタにログ出力を加え、上記3パターンのメソッドチェインをした際の、ログを比較し、挙動の確認をしてみました。

コードは以下のとおりです。

https://github.com/marudedameo2019/sresult/blob/main/railway_lambda_with_myvector.cpp

実行したときのログは以下のようになります。

```shell-session
PS C:\sresult> .\build_vs\Release\railway_lambda_with_myvector.exe
[one variable]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(myvec&&)
myvec(myvec&&)
~myvec()
~myvec()
3
~myvec()

[not const]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(const myvec&)
myvec(const myvec&)
3
3
3
~myvec()
~myvec()
~myvec()

[const]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(const myvec&)
myvec(const myvec&)
3
3
3
~myvec()
~myvec()
~myvec()
PS C:\sresult>
```

この結果を見る限り、

- (普通に)メソッドチェインをしたときに各`std::expected`オブジェクトの中身はmoveされる
- メソッドチェインの各結果を変数に格納した場合、`std::expected`オブジェクトの中身はコピーされる
- メソッドチェインの各結果をconst変数に格納した場合、`std::expected`オブジェクトの中身はコピーされる

ことが分かります。結果自体が右辺値でない限りは勝手にmoveされないし、右辺値だった場合は勝手にmoveされるということです。仕組みが分かれば便利ですね。うっかり中間結果を保存した場合は、中間結果確認後、能動的に`std::move()`してから`and_then()`なり`transform()`なりしないとmoveしなくてメモリが危うくなるでしょう。

## 3-2. 簡易計測でメモリを確認

1GB分のvectorを用意し、これを値として持つ`std::expected`を10回`transform_error()`して、メモリと時間を測定してみました。メモリはMSYS2環境のfreeコマンドで確認しています(powershellから`Get-WmiObject Win32_PerfFormattedData_PerfOS_Memory`でも出来ますが、遅いし長いので今回はパス)。コードは以下のとおりです。

https://github.com/marudedameo2019/sresult/blob/main/railway_lambda_bench.cpp

チェインの長さを可変にしたくて再帰で呼んだのですが、ちょっと分かりにくくなってしまいました。

結果は以下のとおりです。

```shell-session
user@host UCRT64 /c/sresult
$ ./build/railway_lambda_bench.exe
               total        used        free      shared  buff/cache   available
Mem:            63Gi        29Gi        34Gi          0B          0B        34Gi
Swap:          4.0Gi       110Mi       3.9Gi
time: 0.255
time: 0.256
time: 0.256
time: 0.256
time: 0.256
time: 0.257
time: 0.257
time: 0.257
time: 0.257
time: 0.258
time: 0.258
               total        used        free      shared  buff/cache   available
Mem:            63Gi        30Gi        33Gi          0B          0B        33Gi
Swap:          4.0Gi       110Mi       3.9Gi
size: 268435456

user@host UCRT64 /c/sresult
$
```

最初の250msくらいは1GB分のメモリ生成に使っており、そのあと10回出ているのが`transform_error()`メソッドチェインでの経過時間です。つまり`transform_error()`メソッドチェイン自体では3msくらいしか使っていません(それでも多い気はするけどコピーが発生してたら250msくらいかかる)。

結論としては、右辺値にメソッドチェインしていけばmoveが発生し、メモリを消費を抑えられ、時間もかからない、ということが確認できました。

# 4. C++17対応について

上記の動作などを見て仕様を確認しつつ、C++17用に簡易実装したのが[`sresult.h`](https://github.com/marudedameo2019/sresult/blob/main/sresult.h)というローカルヘッダです。今回のコード群ではC++23未満なら自動で使用されています。仕組みを見るのに`std::expected`本体を追うのは辛いかもしれないので、何となく理解できるように短く書こうとした適当なコードです。が、const/非constと&/&&の4パターンで似たような実装が必要になり、ちょっと嵩張り、結局追いにくいかもしれません。

また、lambda式を好んで使ったせいかgcc C++17ではreturn時にコピーが発生してしまうケースがあるので注意してください。

:::details railway_lambda_with_myvectorの実行例
```shell-session
user@host UCRT64 /c/sresult
$ ./build/railway_lambda_with_myvector
[one variable]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(const myvec&)
myvec(myvec&&)
~myvec()
myvec(myvec&&)
~myvec()
~myvec()
3
~myvec()

[not const]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(const myvec&)
myvec(myvec&&)
~myvec()
myvec(const myvec&)
3
3
3
~myvec()
~myvec()
~myvec()

[const]
create_vec(auto)
myvec()
myvec(myvec&&)
~myvec()
nop(auto)
myvec(const myvec&)
myvec(myvec&&)
~myvec()
myvec(const myvec&)
3
3
3
~myvec()
~myvec()
~myvec()

user@host UCRT64 /c/sresult
$ 
```
:::

なおこの簡易実装は実用には堪えないので、C++23未満で`std::expected`相当な機能が必要な場合は以下のコードを使いましょう。

https://github.com/TartanLlama/expected
https://github.com/zeus-cpp/expected

上のやつはC++11に対応していて、下のはC++17以降に対応のようです。github上のstarは圧倒的に上のやつが多く、std::expectedの仕様との乖離も少ないとか何とか…。

# 5. まとめ

- `std::expected`を使うと、関数を跨ぐ例外をなくし、railwayなコードが書ける
- 右辺値にメソッドチェインしていくと、自動で移動するので便利